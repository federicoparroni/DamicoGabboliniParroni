\chapter{Code structure}

\section{Server code structure}
The server code is organized in 3 main files:

\classDescription{index.php}
This file contains the entry point of the web api. The central object of this part is \$app, a Slim/App object that is responsible of all the API handling mechanism. The logical code flow is the following:

\begin{enumerate}
\item at first, it initializes a db connection reference (in order to use afterwards). This object (of PDO class) is useful to query the database and retrieve data in a high level manner.
\item it initializes the Authorization Server object and related Storage, providing the possibility to use the database as support to save and set authorization token to the client that will connect to the server. These classes offers a middleware layer used for authorization control.
\item it registers several routes. These allows to establish a mapping between an url request and a callback (that will handle that request and will send a response). For instance, when we go to <domain>/travlendar/public/api/user/profile, we handle that request with a callback (UserController::Profile) located in somewhere in the class structure. The majority of the routes has been set up with the authorization middleware, in order to be accessed only if the request contains a valid access token.
\end{enumerate}

\classDescription{controllers/AuthenticationController.php}
The class contained in this file manages the user authentication. This means that a user can register to the application and then be recognized through its credentials. The method Register is the callback for the /travlendar/public/api/register api. The method allows a user to register providing valid email and password.

\classDescription{controllers/UserController.php}
The class contained in this file manages all the data related to a particular user, for example, profile, appointments, schedules... The method Profile is the callback for the /travlendar/public/api/user/profile api. The method allows to retrieve the information about a user profile (bike, car and public means pass).

\section{Client application code structure}

\classDescription{Controller/IdentityManager}
This class manages all the necessary step allowing a user to be authenticated in the application. It is made up of 5 main methods:

\begin{enumerate}
\item TokenRequest: sends an asincronous request to the token api and return the obtained token through the specified callback
\item Login: basically call TokenRequest with the provided email and password and cache those credentials with the token in case of success
\item Register: call asincronously the register api passing the specified email and password
\item GetUserProfile: call asincronously the user profile api passing the specified email and password
\item Logout: de-cache the user credentials and token
\end{enumerate}


\classDescription{Controller/ViewController/Login}
The activity that handle the interaction between the user and the Login view. The activity calls IdentityManager methods to perform login and registration processes.

\classDescription{Controller/Scheduler}
This class is used to compute asincronously a new schedule. Inputs are an appointments list, a starting time, a starting location, some constraints and an optimization criteria. The only exposed method are IsConsistent and ComputeSchedule. The first one check if all the input parameters have been set correctly. The second one actually does the big work. It perform the following actions:
\begin{enumerate}
\item retrieving weather conditions information
\item computing predecessors and distances matrixes (see \DDref{3.2}) of all the appointments
\item recursively building arrangements (all the possible ways of ordering the  appointments consistently with respect to the starting times)
\item trying to create a schedule from each arrangement. This consists of some substeps:
\begin{enumerate}
\item create temporary appointment with a wake-up dummy appointment. These appointments have additional information supporting next computations
\item loop two by two the temporary appointments until the end and assign the best travel mean to the second. The best travel mean is chosen from the available and usable list of travel means. This brings to also assign the starting time and the cost (time, cost, carbon), calculated for that travel mean.
\item check if there are a time conflict (starting time of the current appointment and ending time of the previous are overlapping) or a mean conflict (taking that mean causes to exceed the maximum distance imposed by some constraints).
\item if confilicts are found, add a dummy constraint on a temporary appointment to avoid taking that mean. In case of time conflict, this dummy constraints allows to take a faster travel mean (penalizing at least the cost); in case of mean conflict, it allows to take a different mean (penalizing at least the time).
\item repeat from point (b) until there are no more time/mean conflicts or no more dummy constraints can be added to any appointment
\end{enumerate}

\item ordering all the created schedules
\item calling the mapping service api to get route information on the "best" schedule (with the least cost) and verify the real feasibility of that schedule (done by calling \hyperref[method:getBestScheduleAsync]{ \textit{getBestScheduleAsync}}, see below for more details)
\item returning the schedule if feasible or null otherwise
\end{enumerate}

\label{method:getBestScheduleAsync} \methodDescription{getBestScheduleAsync} it's the point were the API calls are performed to get the real data for a schedule, and to decide if the schedules (ordered by the most convenient one) are actually feasible, infact all the computation was based on estimates so far.
The method takes every schedule that was computed, starting from the most convenient one, and performs the API calls (\methodDescription{getTravelOptionData} in particular) for every couple of scheduled appointments of the schedule, passing theire locations and starting times as parameters. If the results don't fit on the timings that were previously calculated, the schedule it's discarded and we try with the next one, until we conclude that there's a feasible schedule or not.
In case a schedule it's accepted by this method, the various calls that were performed have set all the useful data for further computation on the \textbf{TravelOptionData} object, linking couples of scheduled appointments of the schedule.
When the method terminates, the listener it's called, passing the computed schedule, if any, or null. Infact, since also the Scheduler deals with asynchronous calls (perfomed in \methodDescription{getBestScheduleAsync}) it has to provide an interface through which getting the results back.
When the caller will receive the results, it will add it to the list of schedules.


\classDescription{ScheduleManager}
It lists all the schedules that have been computed over time, other than an handle to the current schedule that it's under execution right now. Based on this variable, the \textbf{HomeFragment} can decide it's state. The class offers also the method \methodDescription{getDirectionsForRunningSchedule} which retrieves, by means of the \textbf{TravelOptionData} objects contained in the schedule, a textual representation for the directions to give to the user.
This class is made up as a Singleton, since just an instance of this object can be available.

\classDescription{AppointmentManager}
It lists all the appointments that have been created over time. It also offers a method which, relying on the \methodDescription{getStopDistance} method of \textbf{MappingServiceAPIWrapper}, sets the minimun distances to each kind of transit stop, from the selected appointment.
This class is made up as a Singleton, since just an instance of this object can be available.

\classDescription{HomeFragment}
It's the view that first appears to the user when he/she opens the application. It has, as background, an object of type \textbf{GoogleMap}, showing all the appointments of the actual day, spreaded across the region that it's considered. This is the view as it shows up with it's starting state, that is, without any schedule on running. The state of it changes when some schedule is ran: the map is resized and at the bottom appear the directions for the schedule that it's actually running. When a schedule it's stopped (by means of the Cross button on the view), the state of the view returns as initial.

\classDescription{UserProfileFragment}
It's the view that lets the user change it's personal parameters, saved and managed by the built-in \textbf{SharedPreferences} environment in Android.

\classDescription{ScheduleListFragment}
Interprets in a graphic way, by means of an \textbf{ArrayAdapter}, the list of computed schedules contained in the \textbf{ScheduleManager} as a \textbf{ListView}. Using the filter features granted by the ArrayAdapter class, it separates the schedules in past schedules and current schedules (that are computed for the current day or in the future). 

\classDescription{MapUtils}
Encapsulates a \textbf{GoogleMap} object, allowing to draw a schedule (meaning all the appointments as markers and the polylines linking the appointments as lines of different colors) or a list of appointments (meaning as a set of markers) on map. Note that this it's implemented as a static class instead of an extension of the \textbf{GoogleMap} class because \textbf{GoogleMap} it's declared as static.

\subsection{API wrappers} \label{sect:APIWrappers}
As underlined in \DDref{2.2}, an indipendent set of components of our application is represented by the API wrappers. That is, they represents the way in which the system gather information from the external world. These informations, together with the internal data provided by the user, are the fundamental ingredients for the schedule computation.
The use of the Adapter pattern (as introduced in \DDref{2.6}) is adopted for any class belonging to this subset of components, since we had these needs:

\begin{enumerate}
\item Retrieve data in a format that was requested by the other classes;
\item Separate the other classes from the specific external API service that was used;
\end{enumerate}

The Adapter pattern fits perfectly these requests, leaving these part of the application totally open to modifications: if we will have the need to use another external source of data, will be enough to change the Adapter class, leaving the methods firm unchanged.
Moreover, all these classes are Singletons: just one instance of a wrapper its needed.
Last, since all the classes perform asynchronous calls, the results from these wrappers can be obtained only by extending the interfaces that they provide, and passing those objects to the methods that perform the calls (say, \methodDescription{getWeather}, \methodDescription{getTravelOptionData}, etc..), as suggested by asynchronous programming patters.

\classDescription{WeatherForecastAPIWrapper}
This subcomponent relays on another wrapper which was already built for the DarkSky libraries, so, basically, we exploited the functionalities of this wrapper adapting the data for our purposes. In particular, by calling \methodDescription{getWeather}, we can retrieve the weather conditions for the next 48 in a certain location, starting on a certain date. This can lead to the possibility of caching the weather data, saving some API calls when not needed

\classDescription{MappingServiceAPIWrapper}
This subcomponent relays on another 2 wrappers which were already built for the Google Places API and Google Directions API. Two features are offered:

\begin{enumerate}
\item \methodDescription{getStopDistance}: useful to retrieve all the transit stops that can be found in a certain range, with the relative distance from a specified location.
\item \methodDescription{getTravelOptionData}: useful to retrieve all the useful data about the travelling from a spot to another, specifying a deterministic starting time. These data are filled in a \textbf{TravelOptionData} object, which is a field available in every scheduled appointment.
\end{enumerate}

\classDescription{TravelMeanAPIWrapper}
This class it's not implemented because it deals with strike days and tickets, which are details that are not considered in our prototype, as explained in \ref{chap:reqAndFuct}

